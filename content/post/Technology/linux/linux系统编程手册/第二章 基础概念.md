---
title: "第二章_基本概念"
subtitle: ""
date: 2023-09-19T09:12:08+08:00
lastmod: 2023-09-19T09:12:08+08:00
draft: false
authors: [vee]
description: ""

tags: []
categories: []
series: [linux系统编程手册]

hiddenFromHomePage: false
hiddenFromSearch: false

top: true

lightgallery: false
image: "img/defaultImg.jpg"
---

<!--more-->

## 操作系统的核心——内核

### 内核的职责

- 进程调度：linx是抢占式多任务操作系统，多个进程可同时驻留内存，由**内核进程调度程序**决定进程何时使用cpu，以及使用的时长。
- 内存管理：linx采用虚拟内存管理机制，使进程与进程之间、进程与内核之间隔离，保障安全；并且只需将进程的一部分保持在内存中，节省内存。
- 提供文件系统。
- 创建和终止进程。
- 对设备的访问。
- 联网
- 提供系统调用应用编程接口。

### 内核态与用户态

CPU可在两种不同状态下来回切换运行：

- 内核态
- 用户态

虚拟内存也可被标记为：

- 内核空间
- 用户空间

对应关系：

- CPU在用户态下运行时，只能访问内存的用户空间
- CPU在内核态下运行时，既可访问用户空间，也可访问内核空间

CPU只有在内核态时，才能执行某些特定操作，且**操作系统一般位于内核空间**。

### 以进程及内核视角检视系统

#### 进程视角

执行中的进程：

- 无法知道自己对CPU的使用情况
- 无法知道系统对进程如何分配
- 无法知道何时收到信号、IPC（内核统一协调）
- 不知道自己在RAM中的位置
- 无法创建新的进程
- 无法自主退出
- 无法直接与硬件交互

## shell

略。

## 用户和组

### 用户

系统对每个用户都拥有唯一的登录名（用户名）和**整数型用户ID（UID）**。

系统密码文件`/etc/passwd`为每个用户都定义一行记录，还包含：

- 组ID：用户所属第一个组的整数型ID。
- 主目录：用户登录后的初始目录。
- 登录shell：执行以解释用户命令的程序。
- 密码（已加密）：出于安全考虑，一般存储于单独的shadow密码文件中，仅供特权用户read。

### 组

保存在`/etc/group`文件，每条记录包含：

- 组名：（唯一）组名称。
- 组ID(GID)：与组相关的整数型ID。
- 用户列表：隶属于该组的用户登录名列表。

### 超级用户

0号用户，通常为root，凌驾于系统的权限检查之上，有权访问所有文件，也能发送信号干预系统运行的所有用户进程。

## 单根目录层级、目录、连接及文件

linux内核维护着一套**单根**目录结构，根目录为`/`，与windows的多根目录结构不同。（windows每个磁盘设备都有各自的目录层级）。

### 文件类型

- 普通文件
- 纯文本文件
- 设备
- 管道
- 套接字
- 目录
- 符号链接

### 路径和链接

目录是一种特殊的文件，内容采用表格形式，数据项包括文件名以及对文件的引用。

链接 = 文件名 + 指针

每个文件可以有多条链接，也可以有多个名称。

**每个目录至少包含两条记录**：

- `.` 指向自己
- `..`指向上级目录，对于根目录则指向根目录自身

### 符号链接

符号链接 = 文件名 + 指针（指向另一个指针）

### 文件的所有权和权限

每个文件都有一个与之相关的的用户ID和组ID，分别定义文件的属主和属组。

围绕文件，系统把用户分为三类：

- 文件的属主
- 同组成员
- 其他用户

## 文件IO模型

UNIX系统I/O模型通用操作：

- open()
- read()
- write()
- close()

UNIX系统没有文件结束符，读到文件末尾没有数据返回就会认定为抵达文件末尾。

### 文件描述符

- 0 标准输入  stdin
- 1 标准输出  stdout
- 2 标准错误  stderr

## 程序

略

## 进程

正在运行的程序实例。

### 进程的内存布局

- 文本：程序的指令
- 数据：程序使用的静态变量
- 堆：程序可从该区域动态分配额外的内存
- 栈：随函数调用、返回而增减的一片内存，用于为局部变量、函数调用链接信息分配储存空间。

### 创建和执行程序

可以通过`fork()`父进程来创建子进程。

内核通过对父进程的**复制**来创建子进程。子进程从父进程集成数据段、栈段、以及堆段后，可以修改这些内容，不会影响父进程。

### 进程ID和父进程ID

- 每一个进程都有一个唯一ID
- 还具有唯一的父进程ID（PPID）

### 进程终止和终止状态

如何终止进程：

- 进程可使用`_exit()`系统调用请求退出；
- 向进程传递信号将其杀死。

进程退出时，会生成一个**非负小数**表示其终止状态，并返回给父进程的`wait()`函数。一般情况下：

- 0：功成身退
- 非0：发生错误

### 进程的用户和组标识符（凭证）

每个进程都有一组与之相关的用户(UID)和组（GID）:

- 真实用户ID和组ID：用来标识进程所属的用户和组。
- 有效用户ID和组ID：进程访问受保护的资源时使用的ID，一般与真实ID相同，也可以改。
- 补充组ID：用来标识进程所属的额外组。

### 特权进程

  指用户ID为0（root）的进程。

### 能力

可以先理解为权限，root具备所有权限。

### init进程

- 系统创建的第一个进程
- 所有进程之父
- 程序文件为`/sbin/init`
- 具备root权限
- 不能被kill（root都不行），只有关闭系统才能终止。
- 主要任务是创建并监控系统运行所需的一系列进程。

### 守护进程

- 通常在系统引导时启动直至系统关闭；
- 后台运行，且无控制终端供其读写数据。

eg:

- syslogd
- httpd

### 环境列表

每个进程都有一份环境列表，就是在进程用户空间内存中维护的一组key-value形式的环境变量。

进程被fork出来后会集成父进程的环境副本。

>可以使用export命令来创建环境变量，如：`$ export ENV='haha'`

### 资源限制

每个进程都会消耗资源，使用`setrlimmit()`进程可为自己消耗的各类资源设定上限：

- `soft limmit`限制了进程可以消耗的资源总量
- `hard limmit`是软限制的调整上限。

## 内存映射

>调用系统函数`mmap()`的进程，会在其虚拟地址空间中创建一个新的内存映射。

映射分为：

- 文件映射：将文件的部分区域映射进调用进程的虚拟内存，可把对文件内容的访问转化为对相应内存区域的字节操作。
- 匿名映射：没有文件内容，其内容会初始化为0.

以映射共享内容：

- 两个进程映射同一文件的相同部分。
- fork()出的子进程集成父进程的映射。

内存映射可见性以映射时传入的参数是“私有”还是“共享”来决定。

## 静态库与动态库

暂略。

## 进程间通信和同步

Linux提供的IPC机制：

- 信号（signal），用来表示事件的发生。
- 管道（|操作符），用于在进程间传递数据。
- 套接字，用来传递数据。
- 文件锁定，为了防止其他进程读写文件内容，因而对文件的部分区域加以锁定。
- 消息队列，传递数据（包）
- 信号量（semaphore），用来同步进程动作。
- 共享内存。

## 信号